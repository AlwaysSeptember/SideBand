{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/howler/dist/howler.js","webpack:///(webpack)/buildin/global.js","webpack:///../src/constants.js","webpack:///../src/options.js","webpack:///../src/component.js","webpack:///../src/render.js","webpack:///./tsx/events.tsx","webpack:///../src/util.js","webpack:///../src/create-element.js","webpack:///../src/diff/children.js","webpack:///../src/diff/props.js","webpack:///../src/diff/index.js","webpack:///../src/diff/catch-error.js","webpack:///./node_modules/danack-message/src/index.ts","webpack:///./tsx/SoundButtonPanel.tsx","webpack:///./tsx/CommsPanel.tsx","webpack:///./tsx/SideBandPanel.tsx","webpack:///./node_modules/widgety/src/index.ts","webpack:///./tsx/bootstrap.tsx","webpack:///./tsx/PeopleListPanel.tsx"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","HowlerGlobal","this","init","self","Howler","_counter","_html5AudioPool","html5PoolSize","_codecs","_howls","_muted","_volume","_canPlayEvent","_navigator","window","navigator","masterGain","noAudio","usingWebAudio","autoSuspend","ctx","autoUnlock","_setup","volume","vol","parseFloat","setupAudioContext","gain","setValueAtTime","currentTime","length","_webAudio","ids","_getSoundIds","j","sound","_soundById","_node","mute","muted","stop","unload","close","codecs","ext","replace","state","_autoSuspend","Audio","oncanplaythrough","e","_setupCodecs","audioTest","err","canPlayType","mpegTest","checkOpera","userAgent","match","isOldOpera","parseInt","split","mp3","mpeg","opus","ogg","oga","wav","aac","caf","m4a","m4b","mp4","weba","webm","dolby","flac","_unlockAudio","_audioUnlocked","_mobileUnloaded","sampleRate","_scratchBuffer","createBuffer","unlock","audioNode","_unlocked","_releaseHtml5Audio","load","_autoResume","source","createBufferSource","buffer","connect","destination","start","noteOn","resume","onended","disconnect","document","removeEventListener","_emit","addEventListener","_obtainHtml5Audio","pop","testPlay","play","Promise","then","catch","console","warn","audio","push","suspend","_sounds","_paused","_suspendTimer","clearTimeout","setTimeout","handleSuspension","_resumeAfterSuspend","Howl","src","error","_autoplay","autoplay","_format","format","_html5","html5","_loop","loop","_pool","pool","_preload","preload","_rate","rate","_sprite","sprite","_src","undefined","_xhr","method","xhr","headers","withCredentials","_duration","_state","_endTimers","_queue","_playLock","_onend","onend","fn","_onfade","onfade","_onload","onload","_onloaderror","onloaderror","_onplayerror","onplayerror","_onpause","onpause","_onplay","onplay","_onstop","onstop","_onmute","onmute","_onvolume","onvolume","_onrate","onrate","_onseek","onseek","_onunlock","onunlock","_onresume","event","action","url","str","exec","toLowerCase","location","protocol","slice","Sound","loadBuffer","internal","id","num","_ended","_id","_inactiveSound","soundId","_loadQueue","seek","Math","max","_seek","duration","timeout","abs","setParams","_start","_stop","node","playWebAudio","_refreshBuffer","_playStart","bufferSource","noteGrainOn","Infinity","once","_clearTimer","playHtml5","playbackRate","paused","loadedNoReadyState","ejecta","readyState","isCocoonJS","listener","pause","_rateSeek","_stopFade","noteOff","_cleanBuffer","isNaN","arguments","_clearSound","_interval","args","index","indexOf","apply","fade","from","to","len","min","end","linearRampToValueAtTime","_startFadeInterval","isGroup","diff","steps","stepLen","lastTick","Date","now","_fadeTo","setInterval","tick","round","clearInterval","cancelScheduledValues","loopStart","loopEnd","playing","realTime","rateSeek","seekAndEmit","emitSeek","sounds","_errorFn","_loadFn","splice","remCache","cache","on","events","off","isId","keys","Array","isArray","msg","task","shift","ended","_drain","reset","limit","cnt","_panner","isIOS","vendor","test","howl","_parent","parent","createGain","createGainNode","_errorListener","_loadListener","code","ceil","__default","loadSound","data","atob","dataView","Uint8Array","charCodeAt","decodeAudioData","XMLHttpRequest","open","responseType","forEach","setRequestHeader","status","response","onerror","safeXhrSend","send","arraybuffer","success","AudioContext","webkitAudioContext","iOS","platform","appVersion","version","safari","global","_super","_pos","_orientation","stereo","pan","pos","x","y","z","positionX","setTargetAtTime","positionY","positionZ","setPosition","orientation","xUp","yUp","zUp","or","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","_stereo","_pannerAttr","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","panningModel","refDistance","rolloffFactor","_onstereo","onstereo","_onpos","onpos","_onorientation","onorientation","pannerType","createStereoPanner","setupPanner","orientationX","orientationY","orientationZ","pannerAttr","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_distanceModel","_maxDistance","_refDistance","_rolloffFactor","_panningModel","pa","panner","type","createPanner","g","Function","options","rerenderQueue","defer","prevDebounce","IS_HYDRATE","EventType","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","parentNode","removeChild","createElement","children","normalizedProps","defaultProps","createVNode","ref","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","sibling","updateParentDomPointers","child","base","enqueueRender","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","placeChild","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","setStyle","style","setProperty","dom","oldValue","useCapture","nameLower","cssText","eventProxy","_listeners","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","reorderChildren","newVNode","tmp","isNew","oldProps","oldState","snapshot","clearProcessingException","newProps","provider","componentContext","newType","contextType","render","doRender","sub","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","oldHtml","newHtml","nodeType","localName","createTextNode","createElementNS","is","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","hydrate","diffProps","checked","current","parentVNode","skipRemove","componentWillUnmount","replaceNode","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","forceUpdate","resolve","messageProcessingActive","messageProcessingEverActive","notStartedWarningTimeout","messageQueue","messsageListeners","messsageListenersTypes","next_id","registerMessageListener","messageType","unregisterListener","log","timeoutDebugInfo","triggerMessageInternal","eventType","params","callbacks","sendMessage","notStartedWarningTime","SoundButtonPanel","onClick","clickWasPressed","trigger_sound","text","super","connectInterval","ws","message_listener","WebSocket","onopen","onOpen","onmessage","messageEvent","onMessage","onclose","onClose","onError","check","CLOSED","connection_state","sendSound","sound_data","username","JSON","stringify","parse","received_sound","reason","message","setupWidgetForElement","element","h","dataset","json","widgety_json","setupWidget","widgetBindings","domElements","getElementsByClassName","class","domElementsSnapshot","item","widgetBinding","usernameInput","playSound","filenames","filename","target","new_value","currentTarget","onChange","handleChange","setUsername","changeVolume","listClearing","soundEvents","listPerson","clearList","newList","soundEvent","date","time","seconds","newSoundEvents","unshift","soundEventsBlah","map","messageData","startMessageProcessing"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n *  howler.js v2.2.0\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function() {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function() {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n\n      return self;\n    },\n\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function(vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n\n        return self;\n      }\n\n      return self._volume;\n    },\n\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function(muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i=0; i<self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j=0; j<ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n\n            if (sound && sound._node) {\n              sound._node.muted = (muted) ? true : sound._muted;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Handle stopping all sounds globally.\n     */\n    stop: function() {\n      var self = this || Howler;\n\n      // Loop through all Howls and stop them.\n      for (var i=0; i<self._howls.length; i++) {\n        self._howls[i].stop();\n      }\n\n      return self;\n    },\n\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function() {\n      var self = this || Howler;\n\n      for (var i=self._howls.length-1; i>=0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function(ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function() {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch(e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n\n      return self;\n    },\n\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function() {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\\/([0-6].)/g);\n      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);\n\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n\n      return self;\n    },\n\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function() {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function(e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        while (self._html5AudioPool.length < self.html5PoolSize) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n            break;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i=0; i<self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j=0; j<ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function() {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n\n      return self;\n    },\n\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function() {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function() {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n\n      return new Audio();\n    },\n\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function(audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n\n      return self;\n    },\n\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function() {\n      var self = this;\n\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i=0; i<self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j=0; j<self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function() {\n        if (!self.autoSuspend) {\n          return;\n        }\n\n        self._suspendTimer = null;\n        self.state = 'suspending';\n\n        // Handle updating the state of the audio context after suspending.\n        var handleSuspension = function() {\n          self.state = 'suspended';\n\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        };\n\n        // Either the state gets suspended or it is interrupted.\n        // Either way, we need to update the state to suspended.\n        self.ctx.suspend().then(handleSuspension, handleSuspension);\n      }, 30000);\n\n      return self;\n    },\n\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function() {\n      var self = this;\n\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\n        self.ctx.resume().then(function() {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i=0; i<self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function(o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function(o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = (typeof o.format !== 'string') ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = (typeof o.src !== 'string') ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhr = {\n        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\n        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,\n      };\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{fn: o.onend}] : [];\n      self._onfade = o.onfade ? [{fn: o.onfade}] : [];\n      self._onload = o.onload ? [{fn: o.onload}] : [];\n      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];\n      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];\n      self._onpause = o.onpause ? [{fn: o.onpause}] : [];\n      self._onplay = o.onplay ? [{fn: o.onplay}] : [];\n      self._onstop = o.onstop ? [{fn: o.onstop}] : [];\n      self._onmute = o.onmute ? [{fn: o.onmute}] : [];\n      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];\n      self._onrate = o.onrate ? [{fn: o.onrate}] : [];\n      self._onseek = o.onseek ? [{fn: o.onseek}] : [];\n      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload && self._preload !== 'none') {\n        self.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function() {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i=0; i<self._src.length; i++) {\n        var ext, str;\n\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n\n      return self;\n    },\n\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function(sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        if (!self._playLock) {\n          var num = 0;\n          for (var i=0; i<self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function() {\n            self.play(soundId);\n          }\n        });\n\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);\n      var timeout = (duration * 1000) / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function() {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function() {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = (sound._muted || self._muted) ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n\n          if (!internal) {\n            setTimeout(function() {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n\n        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function() {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play\n                .then(function() {\n                  self._playLock = false;\n                  node._unlocked = true;\n                  if (!internal) {\n                    self._emit('play', sound._id);\n                    self._loadQueue();\n                  }\n                })\n                .catch(function() {\n                  self._playLock = false;\n                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                    'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                  // Reset the ended and paused values.\n                  sound._ended = true;\n                  sound._paused = true;\n                });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +\n                'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function() {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n\n          var listener = function() {\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n\n      return sound._id;\n    },\n\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function(id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function() {\n            self.pause(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function(id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function() {\n            self.stop(id);\n          }\n        });\n\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function(muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded'|| self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function() {\n            self.mute(muted, id);\n          }\n        });\n\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n\n          self._emit('mute', sound._id);\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function() {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded'|| self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function() {\n              self.volume.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n\n      return self;\n    },\n\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function(from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function() {\n            self.fade(from, to, len, id);\n          }\n        });\n\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = Math.min(Math.max(0, parseFloat(from)), 1);\n      to = Math.min(Math.max(0, parseFloat(to)), 1);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + (len / 1000);\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function(sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function() {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Make sure the volume is in the right bounds.\n        if (diff < 0) {\n          vol = Math.max(to, vol);\n        } else {\n          vol = Math.min(to, vol);\n        }\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if ((to < from && vol <= to) || (to > from && vol >= to)) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function(id) {\n      var self = this;\n      var sound = self._soundById(id);\n\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function() {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i=0; i<ids.length; i++) {\n        sound = self._soundById(ids[i]);\n\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n            }\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function() {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function() {\n              self.rate.apply(self, args);\n            }\n          });\n\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i=0; i<id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;\n            var timeout = (duration * 1000) / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n\n      return self;\n    },\n\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function() {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return self;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'seek',\n          action: function() {\n            self.seek.apply(self, args);\n          }\n        });\n\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function() {\n            self._emit('seek', id);\n\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function() {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function(id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function(id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n\n      return duration;\n    },\n\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function() {\n      return this._state;\n    },\n\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function() {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i=0; i<sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i=0; i<Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n\n      return null;\n    },\n\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function(event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n\n      if (typeof fn === 'function') {\n        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});\n      }\n\n      return self;\n    },\n\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function(event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i=0; i<events.length; i++) {\n          var isId = (id === events[i].id);\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i=0; i<keys.length; i++) {\n          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function(event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n\n      return self;\n    },\n\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function(event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i=events.length-1; i>=0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function(fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n\n      return self;\n    },\n\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function(event) {\n      var self = this;\n\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n\n      return self;\n    },\n\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function(sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n\n        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n\n      return self;\n    },\n\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function(id) {\n      var self = this;\n\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n\n        delete self._endTimers[id];\n      }\n\n      return self;\n    },\n\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function(id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function() {\n      var self = this;\n\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function() {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i=0; i<self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i=self._sounds.length - 1; i>=0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function(id) {\n      var self = this;\n\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i=0; i<self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function(sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n\n      return self;\n    },\n\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function(node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}\n        }\n      }\n      node.bufferSource = null;\n\n      return self;\n    },\n\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function(node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function(howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n\n      return self;\n    },\n\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function() {\n      var self = this;\n      var parent = self._parent;\n      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;\n\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = parent._preload === true ? 'auto' : parent._preload;\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n\n      return self;\n    },\n\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n\n      return self;\n    },\n\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function() {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {__default: [0, parent._duration * 1000]};\n      }\n\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function(self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n\n      return;\n    }\n\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i=0; i<data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open(self._xhr.method, url, true);\n      xhr.withCredentials = self._xhr.withCredentials;\n      xhr.responseType = 'arraybuffer';\n\n      // Apply any custom headers to the request.\n      if (self._xhr.headers) {\n        Object.keys(self._xhr.headers).forEach(function(key) {\n          xhr.setRequestHeader(key, self._xhr.headers[key]);\n        });\n      }\n\n      xhr.onload = function() {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function() {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function(xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function(arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function() {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function(buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  }\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function(self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {__default: [0, self._duration * 1000]};\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function() {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch(e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (typeof define === 'function' && define.amd) {\n    define([], function() {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    });\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (typeof exports !== 'undefined') {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Add to global in Node.js (for testing, etc).\n  if (typeof global !== 'undefined') {\n    global.HowlerGlobal = HowlerGlobal;\n    global.Howler = Howler;\n    global.Howl = Howl;\n    global.Sound = Sound;\n  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  }\n})();\n\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.0\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function() {\n\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function(pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i=self._howls.length-1; i>=0; i--) {\n      self._howls[i].stereo(pan);\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function(x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._pos[1] : y;\n    z = (typeof z !== 'number') ? self._pos[2] : z;\n\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = (typeof y !== 'number') ? or[1] : y;\n    z = (typeof z !== 'number') ? or[2] : z;\n    xUp = (typeof xUp !== 'number') ? or[3] : xUp;\n    yUp = (typeof yUp !== 'number') ? or[4] : yUp;\n    zUp = (typeof zUp !== 'number') ? or[5] : zUp;\n\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = (function(_super) {\n    return function(o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];\n      self._onpos = o.onpos ? [{fn: o.onpos}] : [];\n      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  })(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function(pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function() {\n          self.stereo(pan, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function() {\n          self.pos(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? 0 : y;\n    z = (typeof z !== 'number') ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function(x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function() {\n          self.orientation(x, y, z, id);\n        }\n      });\n\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = (typeof y !== 'number') ? self._orientation[1] : y;\n    z = (typeof z !== 'number') ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n\n              setupPanner(sound, 'spatial');\n            }\n\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function() {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i=0; i<ids.length; i++) {\n      sound = self._soundById(ids[i]);\n\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Update the panner values or create a new panner if none exists.\n        var panner = sound._panner;\n        if (panner) {\n          panner.coneInnerAngle = pa.coneInnerAngle;\n          panner.coneOuterAngle = pa.coneOuterAngle;\n          panner.coneOuterGain = pa.coneOuterGain;\n          panner.distanceModel = pa.distanceModel;\n          panner.maxDistance = pa.maxDistance;\n          panner.refDistance = pa.refDistance;\n          panner.rolloffFactor = pa.rolloffFactor;\n          panner.panningModel = pa.panningModel;\n        } else {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n        }\n      }\n    }\n\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  })(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = (function(_super) {\n    return function() {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  })(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function(sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\tupdate = update(s, this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","export enum EventType {\n    // Send a sound to be played to the server\n    send_sound = \"send_sound\",\n\n    // Receive a sound from the server\n    received_sound = \"received_sound\",\n\n    // Button was pressed,  trigger sound\n    trigger_sound = \"trigger_sound\",\n}\n\ntype EventData = {\n    eventType: EventType, params: Object\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\ti;\n\tfor (i in props) {\n\t\tif (i !== 'key' && i !== 'ref') normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(\n\t\ttype,\n\t\tnormalizedProps,\n\t\tprops && props.key,\n\t\tprops && props.ref,\n\t\tnull\n\t);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children) {\n\tif (children == null || typeof children == 'boolean') {\n\t\treturn [];\n\t} else if (Array.isArray(children)) {\n\t\treturn EMPTY_ARR.concat.apply([], children.map(toChildArray));\n\t}\n\n\treturn [children];\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (\n\t\ttypeof value == 'number' &&\n\t\tIS_NON_DIMENSIONAL.test(key) === false\n\t) {\n\t\tstyle[key] = value + 'px';\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else {\n\t\tstyle[key] = value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet s, useCapture, nameLower;\n\n\tif (isSvg) {\n\t\tif (name === 'className') {\n\t\t\tname = 'class';\n\t\t}\n\t} else if (name === 'class') {\n\t\tname = 'className';\n\t}\n\n\tif (name === 'style') {\n\t\ts = dom.style;\n\n\t\tif (typeof value == 'string') {\n\t\t\ts.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\ts.cssText = '';\n\t\t\t\toldValue = null;\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (let i in oldValue) {\n\t\t\t\t\tif (!(value && i in value)) {\n\t\t\t\t\t\tsetStyle(s, i, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (let i in value) {\n\t\t\t\t\tif (!oldValue || value[i] !== oldValue[i]) {\n\t\t\t\t\t\tsetStyle(s, i, value[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tname = (nameLower in dom ? nameLower : name).slice(2);\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t\t(dom._listeners || (dom._listeners = {}))[name] = value;\n\t\t} else {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/^xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import initByClass from '../../widgety/src';\n\ntype Message = {\n  type: string;\n  params: object;\n};\n\ninterface MessageCallback {\n  (params: object): void;\n}\n\n// Whether message processing is active. Events are not processed\n// until startMessageProcessing is called, so that events that are\n// triggered while widgets are being created, aren't dispatched\n// until all widgets are loaded.\nlet messageProcessingActive: boolean = false;\n\n// Record of whether event processing has ever been active\n// If someone sends an event and processing has never been\n// active, we give them an info message of 'you probably\n// forgot to start processing'.\nlet messageProcessingEverActive: boolean = false;\n\n// If an an event is triggered, but event processes has never been started\n// we create a warning timeout, that will show a debug message after x seconds\n// to avoid people staring at their computer, wondering when their events\n// aren't being processed.\nlet notStartedWarningTimeout: any = null;\n\nconst notStartedWarningTime = 5;\n\n// A queue of events that have been stored, rather than dispatched\n// immediately. This is typically used when an app is starting up.\nlet messageQueue: Message[] = [];\n\ninterface MessageListener {\n  [key: string]: MessageCallback;\n}\n\ninterface MessageListenerByType {\n  [key: string]: MessageListener;\n}\n\n// The current listeners to events.\nconst messsageListeners: MessageListenerByType = {};\n\n// let myStr: string = myArray[0];\n\ninterface MessageListenerType {\n  [key: number]: string;\n}\n\nconst messsageListenersTypes: MessageListenerType = {};\n\nlet next_id: number = 0;\n\n/**\n * Register a listener for a particular type of event.\n *\n * @param messageType which event to listen for.\n * @param fn The thing to call when the event is dispatched.\n */\nexport const registerMessageListener = (messageType: string, fn: MessageCallback): number => {\n  const id = next_id;\n  next_id += 1;\n\n  // @ts-ignore: any ...\n  if (messsageListeners[messageType] === undefined) {\n    // @ts-ignore: any ...\n    messsageListeners[messageType] = {};\n  }\n  // @ts-ignore: any ...\n  messsageListeners[messageType][id] = fn;\n  messsageListenersTypes[id] = messageType;\n\n  return id;\n};\n\n/**\n *\n * @param id\n */\nexport const unregisterListener = (id: number) => {\n  let type = messsageListenersTypes[id];\n\n  if (type === undefined) {\n    console.log('Failed to unregisterListener, unknown id ' + id + ' in messsageListenersTypes');\n  }\n\n  delete messsageListeners[type][id];\n\n  // check undefined\n  delete messsageListenersTypes[id];\n};\n\n// Allow messages to be processed, and process any backlog of messages.\nexport const startMessageProcessing = () => {\n  if (notStartedWarningTimeout !== null) {\n    clearTimeout(notStartedWarningTimeout);\n    notStartedWarningTimeout = null;\n  }\n\n  messageProcessingActive = true;\n  messageProcessingEverActive = true;\n\n  while (messageQueue.length > 0) {\n    const messageData = messageQueue.pop();\n\n    if (messageData === undefined) {\n      // A foreach loop! A foreach loop! My kingdom\n      // for a foreach loop!\n      continue;\n      // aka this will never happen.\n    }\n\n    triggerMessageInternal(messageData.type, messageData.params);\n  }\n};\n\n// Stop messages from being processed immediately.\nexport const stopMessageProcessing = () => {\n  messageProcessingActive = false;\n};\n\nexport const timeoutDebugInfo = () => {\n  // TODO - change to just no-console\n  // @ts-ignore: console warning is fine here.\n  console.warn(\n    'You sent a message but message processing has never been activated. Call Message.startMessageProcessing if you want events to be dispatched.',\n  );\n};\n\n/**\n * Actually process the event.\n *\n * @param eventType\n * @param params\n */\nfunction triggerMessageInternal(eventType: string, params: object) {\n  // @ts-ignore: any ...\n  if (messsageListeners[eventType] === undefined) {\n    // console.error('unknown event type ' + event);\n    return;\n  }\n  // @ts-ignore: any ...\n  const callbacks = messsageListeners[eventType];\n\n  const keys = Object.keys(callbacks);\n  for (const i in keys) {\n    if (keys.hasOwnProperty(i) !== true) {\n      continue;\n    }\n\n    const keyName = keys[i];\n    const fn = callbacks[keyName];\n    fn(params);\n  }\n}\n\nexport const sendMessage = (eventType: string, params: object) => {\n  // if event processing is active, process it.\n  if (messageProcessingActive === true) {\n    return triggerMessageInternal(eventType, params);\n  }\n\n  // If not, store the data for later processing.\n  messageQueue.push({ type: eventType, params });\n\n  // If processing has ever been active, assume they know\n  // what they're doing\n  if (messageProcessingEverActive === true) {\n    return;\n  }\n\n  // Otherwise create a timeout to remind them to call 'startMessageProcessing'\n  notStartedWarningTimeout = setTimeout(timeoutDebugInfo, notStartedWarningTime * 1000);\n};\n\n/**\n * Clear the queued events. This should only have an effect\n * when the processing is disabled, as that is the only time\n * there should be queued events.\n */\nexport const clearMessages = () => {\n  messageQueue = [];\n};\n\n/**\n * Get the queued events. This queue should only have entries\n * when the processing is disabled.\n */\nexport const getQueuedMessages = () => {\n  // TODO - return a copy, because JS.\n  return messageQueue;\n};\n","\nimport { h, render } from \"preact\";\nimport {EventType} from \"./events\";\nimport {sendMessage} from \"danack-message\";\n\nexport interface SoundButtonProps {\n  text: string;\n  type: string;\n\n}\n\nfunction clickWasPressed(type: string) {\n  sendMessage(\n      EventType.trigger_sound,\n      {type: type}\n  );\n}\n\nexport function SoundButtonPanel(props: SoundButtonProps) {\n\n  return <button onClick={() => clickWasPressed(props.type)}>{props.text}</button>;\n}\n\n\n\n","import {h, Component} from \"preact\";\n\nimport { registerMessageListener, unregisterListener } from \"danack-message\";\nimport {EventType} from \"./events\";\nimport {SoundType} from \"./sounds\";\nimport {sendMessage} from \"danack-message\";\n\nexport interface ConnectionPanelProps {\n    username: string;\n}\n\ninterface ConnectionPanelState {\n    // ws: WebSocket|null;\n    connection_state: string;\n}\n\n\nexport class CommsPanel extends Component<ConnectionPanelProps, ConnectionPanelState> {\n\n    connectInterval:number = null;\n    timeout:number = 250; // Initial timeout duration as a class variable\n    ws:WebSocket|null =  null;\n    message_listener:number = 0;\n\n    constructor(props: ConnectionPanelProps) {\n        super(props);\n\n        this.state = {\n            connection_state: \"Init\"\n        };\n    }\n\n    // single websocket instance for the own application and constantly trying to reconnect\n    componentDidMount() {\n        this.connect();\n\n        this.message_listener = registerMessageListener(\n            EventType.trigger_sound,\n            (data: any) => this.sendSound(data)\n        );\n    }\n\n    componentWillUnmount() {\n        unregisterListener(\n            this.message_listener\n        );\n    }\n\n    sendSound(data:Object) {\n        console.log(\"sendSound\");\n        console.log(data);\n\n        let sound_data = {\n            username: this.props.username,\n            // @ts-ignore: yeah, this needs a type\n            type: data.type\n        };\n\n        this.ws.send(JSON.stringify(sound_data));\n    }\n\n    onMessage(messageEvent :MessageEvent ){\n        console.log(\"Received data\");\n        console.log(messageEvent.data);\n        let sound_data = JSON.parse(messageEvent.data);\n        sendMessage(\n            EventType.received_sound,\n            sound_data\n        );\n    }\n\n    onClose(e:any) {\n        console.log(\n            `Socket is closed. Reconnect will be attempted in ${Math.min(\n                10000 / 1000,\n                (this.timeout + this.timeout) / 1000\n            )} second.`,\n            e.reason\n        );\n\n        //increment retry interval\n        this.timeout = this.timeout + this.timeout;\n\n        //call check function after timeout\n        // @ts-ignore: Timeout blah blah\n        this.connectInterval = setTimeout(\n            this.check,\n            Math.min(10000, this.timeout)\n        );\n    };\n\n    onError(err:any) {\n        console.error(\n            \"Socket encountered error: \",\n            // @ts-ignore: message so does exist\n            err.message,\n            \"Closing socket\"\n        );\n        this.setState({\n            connection_state: \"Errored\"\n        });\n\n        this.ws.close();\n    };\n\n\n\n    onOpen() {\n        console.log(\"connected websocket main component\");\n        this.setState({\n              connection_state: \"Open\"\n          });\n\n        this.timeout = 250; // reset timer to 250 on open of websocket connection\n        clearTimeout(this.connectInterval); // clear Interval on on open of websocket connection\n    };\n\n    /**\n     * @function connect\n     * This function establishes the connect with the websocket and also ensures constant reconnection if connection closes\n     */\n    connect = () => {\n        // this.ws = new WebSocket(\"ws://localhost:8001/broadcast\");\n        this.ws = new WebSocket(\"ws://sideband.septemberalways.com/broadcast\");\n        this.ws.onopen = () => this.onOpen;\n        this.ws.onmessage = (messageEvent: MessageEvent) => this.onMessage(messageEvent);\n        this.ws.onclose = e => this.onClose(e);\n        this.ws.onerror = err => this.onError(err);\n    };\n\n    /**\n     * utilited by the @function connect to check if the connection is close, if so attempts to reconnect\n     */\n    check = () => {\n        //check if websocket instance is closed,\n        if (!this.ws || this.ws.readyState == WebSocket.CLOSED) {\n            // reconnect\n            this.connect();\n        }\n    };\n\n    render() {\n        // return <ChildComponent websocket={this.state.ws} />;\n        //connection_state is {this.state.connection_state}\n        return <div>\n            &nbsp;\n        </div>\n    }\n}","import {h, Component} from \"preact\";\n\nimport { SoundButtonPanel } from \"./SoundButtonPanel\";\nimport {EventType} from \"./events\";\nimport { registerMessageListener, unregisterListener } from \"danack-message\";\n\nimport { CommsPanel } from \"./CommsPanel\";\n\n\nconst {Howl, Howler} = require('howler');\n\n\n// var sounds = {\n//     \"dead\" : {\n//         url : \"sounds/dead.wav\"\n//     },\n//     \"smash\" : {\n//         url : \"sounds/smash.mp3\",\n//     },\n//     \"ping\" : {\n//         url : \"sounds/ping.mp3\"\n//     },\n//     \"bump\" : {\n//         url : \"sounds/bump.mp3\"\n//     },\n//     \"jump\" : {\n//         url : \"sounds/jump.wav\"\n//     },\n//     \"coin\" : {\n//         url : \"sounds/coin.mp3\"\n//     }\n// };\n//\n//\n// var soundContext = new AudioContext();\n//\n// for(var key in sounds) {\n//     loadSound(key);\n// }\n//\n// function loadSound(name){\n//     var sound = sounds[name];\n//\n//     var url = sound.url;\n//     var buffer = sound.buffer;\n//\n//     var request = new XMLHttpRequest();\n//     request.open('GET', url, true);\n//     request.responseType = 'arraybuffer';\n//\n//     request.onload = function() {\n//         soundContext.decodeAudioData(request.response, function(newBuffer) {\n//             sound.buffer = newBuffer;\n//         });\n//     }\n//\n//     request.send();\n// }\n//\n// function playSound(name, options){\n//     var sound = sounds[name];\n//     var soundVolume = sounds[name].volume || 1;\n//\n//     var buffer = sound.buffer;\n//     if(buffer){\n//         var source = soundContext.createBufferSource();\n//         source.buffer = buffer;\n//\n//         var volume = soundContext.createGain();\n//\n//         if(options) {\n//             if(options.volume) {\n//                 volume.gain.value = soundVolume * options.volume;\n//             }\n//         } else {\n//             volume.gain.value = soundVolume;\n//         }\n//\n//         volume.connect(soundContext.destination);\n//         source.connect(volume);\n//         source.start(0);\n//     }\n// }\n\nexport interface SideBandPanelProps {\n    // api_url: string;\n}\n\ninterface SideBandPanelState {\n    username: string;\n    usernameInput: string;\n    volume: number;\n}\n\nfunction getDefaultState(/*initialControlParams: object*/): SideBandPanelState {\n    return {\n        username: null,\n        usernameInput: \"\",\n        volume: 0.4\n    };\n}\n\nexport class SideBandPanel extends Component<SideBandPanelProps, SideBandPanelState> {\n\n    message_listener:number = 0;\n\n    constructor(props: SideBandPanelProps) {\n        super(props);\n        this.state = getDefaultState();\n    }\n\n    componentDidMount() {\n        this.message_listener = registerMessageListener(\n            EventType.received_sound,\n            (data: any) => this.playSound(data)\n        );\n    }\n\n    componentWillUnmount() {\n        unregisterListener(\n            this.message_listener\n        );\n    };\n\n    playSound(data: any) {\n        let filenames = {\n            'boop': '/sounds/dun-dun-dun.mp3',\n            'meow': '/sounds/meow.mp3',\n            'click': '/sounds/pop.mp3',\n            'question': '/sounds/question.mp3'\n        };\n\n        if(filenames.hasOwnProperty(data.type) !== true) {\n            console.error(\"unknown sound type\");\n            console.error(data.type);\n        }\n\n        // @ts-ignore: yeah, this needs to be typed\n        let filename = filenames[data.type];\n\n        console.log(\"playing sound\");\n        // const params = {\n        //     onend: () => {\n        //         console.info('Sound ended!');\n        //     },\n        //     interrupt: true,\n        // };\n\n        var sound = new Howl({\n            src: [filename],\n            volume: this.state.volume,\n        });\n\n        sound.play();\n    };\n\n\n    handleChange(event:any) {\n        this.setState({usernameInput: event.target.value});\n    }\n\n    setUsername() {\n        this.setState({username: this.state.usernameInput});\n    }\n\n    changeVolume(event:any) {\n\n        let new_value = parseFloat(event.currentTarget.value);\n        if (new_value > 1.0) {\n            new_value = 1.0;\n        }\n\n        if (new_value < 0.0) {\n            new_value = 0.0;\n        }\n\n        this.setState({volume: new_value})\n    }\n\n    render(props: SideBandPanelProps, state: SideBandPanelState) {\n\n        if (this.state.username === null) {\n            return <div>\n                <div>Who are you?</div>\n                <div>\n                    <input type=\"text\"\n                           value={this.state.usernameInput}\n                           onChange={(event:any) => this.handleChange((event))} />\n                    <button onClick={() => this.setUsername()}>Set username</button>\n                </div>\n            </div>\n        }\n\n        return  <div class='motions_panel_react'>\n            Volume: <input\n            type='number'\n            value={this.state.volume}\n            onChange={(event) => this.changeVolume(event)}\n        />\n\n            <CommsPanel username={this.state.username}/><br/>\n\n            <SoundButtonPanel text={\"Click\"} type={\"click\"}/>\n            <SoundButtonPanel text={\"Meow?\"} type={\"meow\"}/>\n            <SoundButtonPanel text={\"Question\"} type={\"question\"}/>\n            <SoundButtonPanel text={\"Dun dun dun\"} type={\"boop\"}/>\n        </div>;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n","// Which React object should be bound to which classes for elements\nexport type WidgetClassBinding = {\n  class: string;\n  component: object;\n};\n\nconst setupWidgetForElement = (element: HTMLOrSVGElement, component: object, h: any, render: any) => {\n  let params = {};\n\n  if (element.dataset.hasOwnProperty('widgety_json') === true) {\n    const json = element.dataset.widgety_json;\n    // This check is redundant.\n    if (json !== undefined) {\n      params = JSON.parse(json);\n    }\n  }\n\n  // const react_type = <component {...params} />;\n  // @ts-ignore: you not helping here.\n  const reactType = h(component, params);\n\n  render(\n    reactType,\n    // @ts-ignore: you not helping here.\n    element,\n  );\n};\n\nconst setupWidget = (widgetBindings: WidgetClassBinding, h: any, render: any) => {\n  const domElements = document.getElementsByClassName(widgetBindings.class);\n  const domElementsSnapshot = [];\n\n  // take a static snapshot of the domElementsSnapshot, to prevent\n  // yo'dawging of widgetBindings creation.\n  for (let i = 0; i < domElements.length; i += 1) {\n    domElementsSnapshot.push(domElements.item(i));\n  }\n\n  for (const j in domElementsSnapshot) {\n    if (domElementsSnapshot.hasOwnProperty(j) !== true) {\n      // This will never happen.\n      continue;\n    }\n\n    const element = domElementsSnapshot[j];\n    // TODO - type check this properly but JS is terrible\n    // if(!(element as HTMLOrSVGElement)){\n    //     continue;\n    // }\n    // @ts-ignore: you not helping here.\n    setupWidgetForElement(element, widgetBindings.component, h, render);\n  }\n};\n\nconst initByClass = (widgetBindings: WidgetClassBinding[], h: any, render: any) => {\n  for (const widgetBinding of widgetBindings) {\n    setupWidget(widgetBinding, h, render);\n  }\n};\nexport default initByClass;","// import \"preact/debug\";\n\nif (process.env.NODE_ENV==='development') {\n    // Must use require here as import statements are only allowed\n    // to exist at the top of a file.\n    require(\"preact/debug\");\n}\n\nimport { h, render } from \"preact\";\nimport { SideBandPanel } from \"./SideBandPanel\";\nimport { CommsPanel } from \"./CommsPanel\";\nimport { PeopleListPanel } from \"./PeopleListPanel\";\n\n\n\nimport initByClass from \"widgety\";\nimport type { WidgetClassBinding } from \"widgety\";\nimport { startMessageProcessing } from \"danack-message\";\n\n\nlet panels: WidgetClassBinding[] = [\n    {\n        class: 'side_band_panel',\n        component: SideBandPanel\n    },\n    // {\n    //     class: 'comms_panel',\n    //     component: CommsPanel\n    // },\n\n    {\n        class: 'people_list_panel',\n        component: PeopleListPanel\n    },\n];\n\ninitByClass(panels, h, render);\n\nstartMessageProcessing();\n\nconsole.log(\"bootstrap finished\");\n\n","import {h, Component} from \"preact\";\n\nimport { SoundButtonPanel } from \"./SoundButtonPanel\";\nimport {EventType} from \"./events\";\nimport { registerMessageListener, unregisterListener } from \"danack-message\";\n\n\nexport interface PeopleListPanelProps {\n\n}\n\ninterface SoundEvent {\n    type: string;\n    username: string;\n    time: number;\n}\n\ninterface PeopleListPanelState {\n    soundEvents: Array<SoundEvent>;\n}\n\nfunction is_over_seconds_ago (date: number, seconds: number) {\n    const previous_time = Date.now() - (1000 * seconds);\n\n    return date < previous_time;\n}\n\nexport class PeopleListPanel extends Component<PeopleListPanelProps, PeopleListPanelState> {\n\n    listClearing: any = null;\n    message_listener:number = 0;\n\n    constructor(props: PeopleListPanelProps) {\n        super(props);\n        this.state = {\n            soundEvents: []\n        };\n    }\n\n    componentDidMount() {\n        this.message_listener = registerMessageListener(\n            EventType.received_sound,\n            (data: any) => this.listPerson(data)\n        );\n\n        this.listClearing = setInterval(() => this.clearList(), 1000);\n    }\n\n    componentWillUnmount() {\n        unregisterListener(\n            this.message_listener\n        );\n\n        clearInterval(this.listClearing)\n    }\n\n    clearList() {\n        let newList = [];\n\n        for (var soundEvent of this.state.soundEvents) {\n            if (is_over_seconds_ago(soundEvent.time, 20) === true) {\n                continue;\n            }\n\n            newList.push(soundEvent);\n        }\n\n        if (newList.length !== this.state.soundEvents.length) {\n            this.setState({soundEvents: newList})\n        }\n    }\n\n    listPerson(data: any) {\n        if (!data.type) {\n            return;\n        }\n        if (!data.username) {\n            return;\n        }\n\n        let soundEvent:SoundEvent = {\n            type: data.type,\n            username: data.username,\n            time: Date.now()\n        };\n\n        let newSoundEvents = this.state.soundEvents;\n        newSoundEvents.unshift(soundEvent);\n        newSoundEvents = newSoundEvents.slice(0, 20);\n\n        this.setState({soundEvents: newSoundEvents});\n    };\n\n    render(props: PeopleListPanelProps, state: PeopleListPanelState) {\n        let soundEventsBlah = this.state.soundEvents.map(\n            (item, key) =>\n                <li key={key}>{item.type} : {item.username}</li>\n        );\n\n        return  <div>\n            <h3>Click list</h3>\n\n            {soundEventsBlah}\n        </div>;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"],"sourceRoot":""}